scilla_version 0

(* This contract implements a fungible token interface a la ERC20.*)

(***************************************************)
(*               Associated library                *)
(***************************************************)

library SwapContract

let one_msg = 
  fun (msg : Message) => 
  let nil_msg = Nil {Message} in
  Cons {Message} msg nil_msg

let le_int =
  fun (a : Uint128) => fun (b : Uint128) =>
    let x = builtin lt a b in
    match x with
    | True => True
    | False =>
      let y = builtin eq a b in
      match y with
      | True => True
      | False => False
      end
end

let pay_off_code : Uint32 = Uint32 1 (* by emitent, to pay off the dbond *)
let liquidation_code : Uint32 = Uint32 2 (* by liqag to deposit value from orig. bond liquidation *)
let dbond_deposit_code : Uint32 = Uint32 3 (* by emitent to deposit acuired tokens *)
let dbond_exchange_code : Uint32 = Uint32 4 (* by dbond holder *)

let zero : Uint128 = Uint128 0
let z = Uint32 0
let zx = builtin ripemd160hash z

type FiatBond = 
    | FiatBondCon of Uint32 (*maturity timestamp*) 
                     String (*ISIN*)
type Fcdb = 
  | FcdbCon of FiatBond (*the fiat bond lying as collateral*)
            Uint128 (*total supply*)
            Uint32 (*maturity timestamp*)
            Uint32 (*retire timestamp*)
            ByStr20 (*issuer of unit of account*)
            Uint128 (*number of unit of account tokens to pay off at maturity, 100 goes for 1 token*)
            ByStr20 (*verification account*)
            ByStr20 (*accounts served as counterparty*)
            ByStr20 (*account served as liquidation agent*)
            Uint32 (*annual percentage rate, 1000 goes for 10%*)
            String (*escrow contract link*)


contract SwapContract
(owner : ByStr20)

field dbonds : Map ByStr20 (Fcdb) = Emp ByStr20 Fcdb
field received_p : Map ByStr20 (Uint128) = Emp ByStr20 Uint128
field received_l : Map ByStr20 (Uint128) = Emp ByStr20 Uint128
field received_d : Map ByStr20 (Uint128) = Emp ByStr20 Uint128
field received_ex : Map ByStr20 (Map ByStr20 Uint128) = Emp ByStr20 (Map ByStr20 Uint128)
field exchangable : Map ByStr20 Uint32 = Emp ByStr20 Uint32

transition AddDbond (dbond : Fcdb)
    ex <- exists dbonds[_sender];
    match ex with
    | True => 
        e = {_eventname : "AddDbondFailureAlreadyExists"; caller : _sender; dbond : dbond};
        event e
    | False =>
        dbonds[_sender] := dbond;
        e = {_eventname : "AddDbondSuccess"; caller : _sender; dbond : dbond};
        event e
    end
end

(* either accepts and exchangable = True or reverts the chain *)
(* if sent more, sends the change back to emitent *)
procedure CheckIfPaid(emitent : ByStr20)
    db_dep <- received_d[emitent];
    p_dep <- received_p[emitent];
    db <- dbonds[emitent];
    db_am = Uint128 0;
    p_am = Uint128 0;
    match db_dep with
    | Some db_dep =>
        db_am = db_dep
    | None =>
    end;
    match p_dep with
    | Some p_dep =>
        p_am = p_dep
    | None =>
    end;
    match db with
    | Some db =>
        match db with 
        | FcdbCon fiat_bond suppl mat_t ret_t pr_iss pr_am ver countrp liqag apr escrlink =>
            left = builtin sub suppl db_am;
            needed = builtin mul left pr_am;
            extra = builtin sub p_am needed;
            is_paid = le_int needed p_am;
            match is_paid with
            | True =>
                true = Uint32 1;
                exchangable[emitent] := true;
                change = builtin lt zero extra;
                match change with
                | True =>
                    msg = { _tag : "Transfer"; _recipient : pr_iss; _amount : extra;
                        to : emitent; tokens : extra; code : Uint32 0};
                    msgs = one_msg msg;
                    send msgs
                | False =>
                end
            | False =>
                e = { _exception : "NotEnoughPayment"};
                throw e
            end
        end
    | None =>
    end
end

(* accumulates price tokens from emitent *)
procedure AcceptPayOff(caller : ByStr20, sender : ByStr20, amount : Uint128)
    db <- dbonds[sender];
    ex <- exists exchangable[sender];
    match ex with
    | True =>
        e = { _exception : "AlreadyPaid"; caller : _sender; sender : sender};
        throw e
    | False =>
        match db with
        | Some db =>
            match db with
            | FcdbCon fiat_bond suppl mat_t ret_t pr_iss pr_am ver countrp liqag apr escrlink =>
                is_pr_iss = builtin eq pr_iss caller;
                match is_pr_iss with
                | True =>
                    received_p[sender] := amount;
                    CheckIfPaid sender
                | False =>
                    e = {_exception : "AcceptPayOffFailureAuth"; caller : _sender; sender : sender};
                    throw e
                end
            end
        | None =>
            e = {_exception : "AcceptPayOffFailureUnknownSender"; caller : _sender; sender : sender};
            throw e
        end
    end
end

procedure AcceptLiquidation(caller : ByStr20, sender : ByStr20, amount : Uint128)
    db <- dbonds[sender];
    ex <- exists exchangable[sender];
    match ex with
    | True =>
        e = { _exception : "AlreadyPaid"; caller : _sender; sender : sender};
        throw e
    | False =>
        match db with
        | Some db =>
            match db with
            | FcdbCon fiat_bond suppl mat_t ret_t pr_iss pr_am ver countrp liqag apr escrlink =>
                is_pr_iss = builtin eq pr_iss caller;
                match is_pr_iss with
                | True =>
                    accept;
                    received_l[sender] := amount;
                    true = Uint32 1;
                    exchangable[sender] := true
                | False =>
                    e = {_exception : "AcceptLiquidationFailureAuth"; caller : _sender; sender : sender};
                    throw e
                end
            end
        | None =>
            e = {_exception : "AcceptLiquidationFailureUnknownSender"; caller : _sender; sender : sender};
            throw e
        end
    end
end

procedure AcceptDbondDep(caller : ByStr20, sender : ByStr20, amount : Uint128)
    is_emitent <- exists dbonds[sender];
    ex <- exists exchangable[sender];
    match ex with
    | True =>
        e = { _exception : "AlreadyPaid"; caller : _sender; sender : sender};
        throw e
    | False =>
        match is_emitent with
        | True =>
            valid_auth = builtin eq caller sender;
            match valid_auth with
            | True =>
                accept;
                received_d[sender] := amount
            | False =>
                e = {_exception : "AcceptDbondDepFailureAuth"; caller : _sender; sender : sender};
                throw e
            end
        | False =>
            e = {_exception : "AcceptPayOffFailureUnknownSender"; caller : _sender; sender : sender};
            throw e
        end
    end
end

(* makes an exchange or aborts *)
procedure ExchangeDbond(caller : ByStr20, sender : ByStr20, amount : Uint128)
    (* caller here is supposed to be dbond contract *)
    is_ex <- exists exchangable[caller];
    match is_ex with
    | True =>
        db <- dbonds[caller];
        p <- received_p[caller];
        l <- received_l[caller];
        p_am = Uint128 0;
        l_am = Uint128 0;
        match p with
        | Some p =>
            p_am = p
        | None =>
        end;
        match l with
        | Some l =>
            l_am = l
        | None =>
        end;
        match db with
        | Some db =>
                match db with
                | FcdbCon fiat_bond suppl mat_t ret_t pr_iss pr_am ver countrp liqag apr escrlink =>
                    accept;
                    total = builtin add l_am p_am;
                    per_db = builtin div total suppl;
                    need_to_send = builtin mul amount per_db;
                    received_ex[caller][sender] := amount;
                    msg = { _tag : "Transfer"; _recipient : pr_iss; _amount : zero;
                        to : sender; tokens : need_to_send; code : Uint32 0};
                    msgs = one_msg msg;
                    send msgs
                end
        | None =>
        end
    | False =>
        e = { _exception : "NotExchangable"};
        throw e
    end
end

(* is triggered on successful incoming transfer *)
transition TransferSuccess (sender : ByStr20, amount : Uint128, code : Uint32)
    pay_off = builtin eq code pay_off_code;
    liquidation = builtin eq code liquidation_code;
    db_dep = builtin eq code dbond_deposit_code;
    db_ex = builtin eq code dbond_exchange_code;
    match pay_off with
    | True =>
        AcceptPayOff _sender  sender  amount
    | False =>
        match liquidation with
        | True =>
            AcceptLiquidation _sender  sender  amount 
        | False =>
            match db_dep with
            | True =>
                AcceptDbondDep _sender  sender  amount
            | False =>
                match db_ex with
                | True =>
                    ExchangeDbond _sender  sender  amount
                | False =>
                    e = { _exception : "InvalidCode"};
                    throw e
                end
            end
        end
    end
end

(* used as success notification only while multiple messages are not supported *)
transition SendSuccPayOff(emitent : ByStr20)
    valid_auth = builtin eq _sender owner;
    match valid_auth with
    | True =>
        msg = { _tag : "OnSuccPayOff"; _recipient : emitent; _amount : zero};
        msgs = one_msg msg;
        send msgs
    | False =>
        e = {_eventname : "SendSuccPayOffFailureAuth"; caller : _sender};
        event e
    end
end

(* used as success notification only while multiple messages are not supported *)
transition SendSuccLiq(emitent : ByStr20)
    valid_auth = builtin eq _sender owner;
    match valid_auth with
    | True =>
        msg = { _tag : "OnSuccLiq"; _recipient : emitent; _amount : zero};
        msgs = one_msg msg;
        send msgs
    | False =>
        e = {_eventname : "SendSuccLiqFailureAuth"; caller : _sender};
        event e
    end
end